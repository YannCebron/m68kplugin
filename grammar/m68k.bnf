/*
 * Copyright 2020 The Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 References:
 
 http://users.encs.concordia.ca/~aagarwal/coen311/motorola68000.txt
 http://www.easy68k.com/files/EASy68KQuickRef.pdf
 https://neo.dmcs.pl/pn/asembler_68000/asm.html
 https://github.com/marhel/r68k/blob/master/tools/src/assembler/parser.rs
*/

{
  parserClass = "com.yanncebron.m68kplugin.lang.M68kParser"
  parserImports = [
    "static com.yanncebron.m68kplugin.lang.psi.M68kTokenTypes.*"
  ]

  implements = "com.yanncebron.m68kplugin.lang.psi.M68kPsiElement"
  extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix = "M68k"
  psiImplClassSuffix = "Impl"
  psiPackage = "com.yanncebron.m68kplugin.lang.psi"
  psiImplPackage = "com.yanncebron.m68kplugin.lang.psi.impl"

  elementTypeHolderClass = "com.yanncebron.m68kplugin.lang.psi.M68kTypes"
  elementTypeClass = "com.yanncebron.m68kplugin.lang.psi.M68kCompositeElementType"

  psiImplUtilClass="com.yanncebron.m68kplugin.lang.psi.impl.M68kPsiImplUtil"

  classHeader = "license.txt"
  generate = [
    java="8"
    tokens = "no"
  ]
  
  pin(".*_instruction") = 1
  name(".*_instruction") = "instruction"
}

root ::= root_item*
private root_item ::= (instructions | labels) {
  recoverWhile = root_item_recover
}
private root_item_recover ::= !(instructions | labels) {
  consumeTokenMethod = "consumeTokenFast"
}
//private     crlf::='\n' // todo stop parsing after line?

private labels ::= label | localLabel

// todo must start on newline? usually not, but not required
// todo full name is: DevPac. prefixed with last non-local label
fake label_base ::= ID {
  implements = "com.intellij.psi.PsiNamedElement"
  mixin = "com.yanncebron.m68kplugin.lang.psi.impl.M68kLabelBaseMixIn"
}

label ::= UNDERSCORE? ID COLON? {
  extends = label_base
}

localLabel ::= DOT ID COLON? {
  pin = 1
  name = "local label"
  extends = label_base
  mixin = "com.yanncebron.m68kplugin.lang.psi.impl.M68kLocalLabelBaseMixIn"
}

// todo sort instructions by frequency?
private instructions ::= directives |

                         move_instructions |

                         misc_instructions |

                         jump_instructions |

                         add_sub_instructions |
                         mul_div_instructions |
                         bcd_instructions|

                         cmp_instructions |

                         bool_instructions |
                         bit_instructions |
                         shift_instructions |

                         bCC_instructions |
                         dbCC_instructions |
                         sCC_instructions

fake data_sized ::= {
  methods = [ getDataSize ]
}

private data_size_byte ::= DOT_B
private data_size_short ::= DOT_S
private data_size_word ::= DOT_W
private data_size_long ::= DOT_L
private data_size_word_long ::= data_size_word | data_size_long {
  name = ".w|l"
}
private data_size_all ::= data_size_byte | data_size_word_long {
  name = ".b|w|l"
}

private data_register ::= DATA_REGISTER {
  name = "data register"
}

private program_counter ::= PC
private program_counter_indirect ::= ID L_PAREN program_counter R_PAREN

private address_register ::= ADDRESS_REGISTER | SP {
  name = "address register"
}
private address_register_pre_decrement ::= MINUS L_PAREN address_register R_PAREN
private address_register_post_increment ::= L_PAREN ADDRESS_REGISTER R_PAREN PLUS
private address_register_indirect ::= (label_ref_expression | MINUS | number_expression)? L_PAREN address_register R_PAREN PLUS? {
  pin = "("
}

private status_register ::= SR
private condition_code_register ::= CCR
private supervisor_stack_pointer ::= SSP
private user_stack_pointer ::= USP

private any_register ::= data_register |
                         address_register |
                         program_counter |
                         status_register | condition_code_register |
                         supervisor_stack_pointer | user_stack_pointer |
                         address_register_indirect |
                         program_counter_indirect 
                         // todo?

// "d0-d7/a1/a4"
private register_range_element ::= adm_drd | adm_ard
register_range ::= register_range_element (MINUS register_range_element)?
register_list ::= register_range (DIV register_range)*

private effective_address ::= program_counter_indirect |
                              (ID L_PAREN address_register R_PAREN) |
                              expression |
                              label_reference
{
  name = "effective address"
}

label_reference ::= ID {
  mixin = "com.yanncebron.m68kplugin.lang.psi.impl.M68kLabelReferenceMixIn"
  name = "label"
}

immediate_data ::= HASH expression {
  pin = 1
  name = "immediate data"
}


// addressing modes  =====================================================
// d0
adm_drd ::= DATA_REGISTER {
  name = "data register"
}
// a0 | sp
adm_ard ::= ADDRESS_REGISTER | SP {
  name = "address register"
}
// Rn
adm_rrd ::= adm_drd | adm_ard {
  name = "data|address register"
}
// (a0)
adm_ari ::= L_PAREN adm_ard R_PAREN
// (a0)+
adm_api ::= L_PAREN adm_ard R_PAREN PLUS
// -(a0)
adm_apd ::= MINUS L_PAREN adm_ard R_PAREN
// index(a0)
adm_adi ::= expression L_PAREN adm_ard R_PAREN
// index(a0,d0)
adm_aix ::= expression L_PAREN adm_ard COMMA adm_rrd R_PAREN
// 4000 | 4000.w | 4000.l 
adm_abs ::= expression data_size_word_long?
// index(pc)
adm_pcd ::= expression L_PAREN PC R_PAREN
// index(pc,d0)
adm_pci ::= expression L_PAREN PC COMMA adm_rrd R_PAREN
// #4000 | #4000.w | #4000.l
adm_imm ::= HASH expression data_size_word_long? {
  pin = 1
  name = "immediate data"
}

// ATTN: ordering in groups
private adm_group_all ::=                   adm_drd | adm_ard | adm_imm | adm_api | adm_ari | adm_apd | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs
private adm_group_all_except_ard ::=        adm_drd |           adm_imm | adm_api | adm_ari | adm_apd | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs
private adm_group_all_except_imm ::=        adm_drd | adm_ard |           adm_api | adm_ari | adm_apd | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs
private adm_group_all_except_pc_imm ::=     adm_drd | adm_ard |           adm_api | adm_ari | adm_apd | adm_adi | adm_aix | adm_abs
private adm_group_all_except_ard_pc_imm ::= adm_drd |                     adm_api | adm_ari | adm_apd | adm_adi | adm_aix | adm_abs

// Move ==================================================================
private move_instructions ::= move_instruction |
                              movea_instruction |
                              moveq_instruction |
                              movem_instruction |
                              movep_instruction

fake move_instruction_base ::= {
  extends = data_sized
}

move_instruction ::= MOVE data_size_all?
                     adm_group_all COMMA adm_group_all_except_pc_imm {
  extends = move_instruction_base
}

movea_instruction ::= MOVEA data_size_word_long?
                      adm_group_all COMMA adm_ard {
  extends = move_instruction_base
}
                                         
moveq_instruction ::= MOVEQ data_size_long?
                      adm_imm COMMA adm_drd {
  extends = move_instruction_base
  methods = [
    source = "adm_imm"
    destination = "adm_drd"
  ]
}

movem_instruction ::= MOVEM data_size_word_long?
                      (
                        ( register_list COMMA (adm_ari | adm_apd | adm_adi | adm_aix | adm_abs) ) |
                        ( (adm_api | adm_ari | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs) COMMA register_list )
                      ) {
  extends = move_instruction_base
}

movep_instruction ::= MOVEP data_size_word_long?
                      (
                        (adm_drd COMMA adm_adi) |
                        (adm_adi COMMA adm_drd)
                      ) {
  extends = move_instruction_base
}


// Jump ==================================================================
private jump_instructions ::= jsr_instruction|
                              bsr_instruction |
                              jmp_instruction |
                              rts_instruction |
                              rte_instruction |
                              rtr_instruction

jsr_instruction ::= JSR effective_address

private bsr_data_size ::= (data_size_short | data_size_word) {
  name = ".s|w"
}
bsr_instruction ::= BSR bsr_data_size? effective_address {
  extends = data_sized
}

jmp_instruction ::= JMP effective_address
rts_instruction ::= RTS
rte_instruction ::= RTE
rtr_instruction ::= RTR

// *bcd ==================================================================
private bcd_instructions ::= abcd_instruction |
                             nbcd_instruction |
                             sbcd_instruction
fake bcd_instruction_base ::= {
  extends = data_sized
}

private bcd_tail_apd ::= adm_apd COMMA adm_apd {
  pin = 1
}
private bcd_tail_drd ::= adm_drd COMMA adm_drd {
  pin = 1
}
private bcd_tail ::= data_size_byte?
                     bcd_tail_drd | bcd_tail_apd

abcd_instruction ::= ABCD bcd_tail {
  extends = bcd_instruction_base
}
sbcd_instruction ::= SBCD bcd_tail {
  extends = bcd_instruction_base
}

nbcd_instruction ::= NBCD data_size_byte? adm_group_all_except_pc_imm {
  extends = data_sized
}

// Add/Sub ==================================================================
private add_sub_instructions ::= add_instruction |
                                 adda_instruction |
                                 addi_instruction |
                                 addq_instruction |
                                 addx_instruction |
                                 sub_instruction |
                                 suba_instruction |
                                 subi_instruction |
                                 subq_instruction |
                                 subx_instruction

private add_sub_tail ::= data_size_all?
  (
    (adm_drd COMMA adm_group_all_except_pc_imm) |
    (adm_imm COMMA adm_group_all_except_pc_imm) |
    (adm_group_all_except_imm COMMA adm_drd)
  )
private add_sub_a_tail ::= data_size_word_long?
  adm_group_all COMMA adm_ard
private add_sub_i_tail ::= data_size_all?
  adm_imm COMMA adm_group_all_except_ard_pc_imm
private add_sub_q_tail ::= data_size_all?
  adm_imm COMMA adm_group_all_except_pc_imm
private add_sub_x_tail ::= data_size_all?
  (
    (adm_drd COMMA adm_drd) |
    (adm_apd COMMA adm_apd)
  )

add_instruction ::= ADD add_sub_tail
adda_instruction ::= ADDA add_sub_a_tail
addi_instruction ::= ADDI add_sub_i_tail
addq_instruction ::= ADDQ add_sub_q_tail
addx_instruction ::= ADDX add_sub_x_tail

sub_instruction ::= SUB add_sub_tail
suba_instruction ::= SUBA add_sub_a_tail
subi_instruction ::= SUBI add_sub_i_tail
subq_instruction ::= SUBQ add_sub_q_tail
subx_instruction ::= SUBX add_sub_x_tail


// Mul/Div ==================================================================
private mul_div_instructions ::= muls_instruction |
                                 mulu_instruction |
                                 divs_instruction |
                                 divu_instruction

private mul_div_tail ::= data_size_word?
                         adm_group_all_except_ard COMMA adm_drd

muls_instruction ::= MULS mul_div_tail
mulu_instruction ::= MULU mul_div_tail
divs_instruction ::= DIVS mul_div_tail
divu_instruction ::= DIVU mul_div_tail


// Boolean ==================================================================
private bool_instructions ::= and_instruction |
                              andi_instruction |
                              or_instruction |
                              ori_instruction |
                              eor_instruction |
                              eori_instruction |
                              not_instruction
fake bool_instruction_base ::= {
  extends = data_sized
}

private bool_tail ::= data_size_all? any_register COMMA any_register
private bool_i_tail ::= data_size_all? immediate_data COMMA any_register

and_instruction ::= AND bool_tail {
  extends = bool_instruction_base
}
andi_instruction ::= ANDI bool_i_tail {
  extends = bool_instruction_base
}

or_instruction ::= OR bool_tail {
  extends = bool_instruction_base
}
ori_instruction ::= ORI bool_i_tail {
  extends = bool_instruction_base
}

eor_instruction ::= EOR bool_tail {
  extends = bool_instruction_base
}
eori_instruction ::= EORI bool_i_tail {
  extends = bool_instruction_base
}

not_instruction ::= NOT data_size_all? adm_group_all_except_ard_pc_imm {
  extends = bool_instruction_base
}


// Misc ==================================================================
private misc_instructions ::= tst_instruction |
                              tas_instruction |
                              lea_instruction |
                              pea_instruction |
                              clr_instruction |

                              nop_instruction |
                              illegal_instruction |
                              reset_instruction |
                              stop_instruction |
                              trap_instruction |
                              trapv_instruction |

                              link_instruction |
                              unlk_instruction |

                              ext_instruction |
                              neg_instruction |
                              negx_instruction |

                              swap_instruction |
                              chk_instruction |
                              exg_instruction

nop_instruction ::= NOP
illegal_instruction ::= ILLEGAL
reset_instruction ::= RESET
stop_instruction ::= STOP adm_imm
trap_instruction ::= TRAP adm_imm
trapv_instruction ::= TRAPV

link_instruction ::= LINK adm_ard COMMA adm_imm
unlk_instruction ::= UNLK adm_ard

lea_instruction ::= LEA data_size_long? effective_address COMMA (address_register | label_reference) {
  extends = data_sized
}
pea_instruction ::= PEA data_size_long? any_register {
  extends = data_sized
}

clr_instruction ::= CLR data_size_all? adm_group_all_except_ard_pc_imm {
  extends = data_sized
}

tst_instruction ::= TST data_size_all? adm_group_all_except_ard_pc_imm {
  extends = data_sized
}
tas_instruction ::= TAS data_size_byte? adm_group_all_except_ard_pc_imm {
  extends = data_sized
}

ext_instruction ::= EXT data_size_word_long? adm_drd {
  extends = data_sized
}

exg_instruction ::= EXG data_size_long? adm_rrd COMMA adm_rrd {
  extends = data_sized
  methods = [
    adm_rrd = ""
    source = "adm_rrd[0]"
    destination = "adm_rrd[1]"
  ]
}

neg_instruction ::= NEG data_size_all? adm_group_all_except_ard_pc_imm {
  extends = data_sized
}
negx_instruction ::= NEGX data_size_all? adm_group_all_except_ard_pc_imm {
  extends = data_sized
}

swap_instruction ::= SWAP data_size_word? adm_drd {
  extends = data_sized
}

chk_instruction ::= CHK data_size_word? adm_group_all_except_ard COMMA adm_drd {
  extends = data_sized
}


// Compare ==================================================================
private cmp_instructions ::= cmp_instruction |
                             cmpa_instruction |
                             cmpi_instruction |
                             cmpm_instruction
fake cmp_instruction_base ::= {
  extends = data_sized
}

cmp_instruction ::= CMP data_size_all?
                    adm_group_all COMMA adm_group_all_except_pc_imm {
  extends = cmp_instruction_base
}
cmpa_instruction ::= CMPA data_size_word_long?
                     adm_group_all COMMA adm_ard {
  extends = cmp_instruction_base
}
cmpi_instruction ::= CMPI data_size_all?
                     adm_imm COMMA adm_group_all_except_ard_pc_imm {
  extends = cmp_instruction_base
}
cmpm_instruction ::= CMPM data_size_all?
                     adm_api COMMA adm_api {
  extends = cmp_instruction_base
  methods = [
    adm_api = ""
    source = "adm_api[0]"
    destination = "adm_api[1]"
  ]
}


// Branch ==================================================================
private CC_data_size ::= (data_size_all | data_size_short) {
  name = ".s|b|w|l"
}

private bCC_instructions ::= bra_instruction |
                             bcs_instruction |
                             blo_instruction |
                             bls_instruction |
                             beq_instruction |
                             bne_instruction |
                             bhi_instruction |
                             bcc_instruction |
                             bhs_instruction |
                             bpl_instruction |
                             bvc_instruction |
                             blt_instruction |
                             ble_instruction |
                             bgt_instruction |
                             bge_instruction |
                             bmi_instruction |
                             bvs_instruction

private bCC_tail ::= CC_data_size? expression

bra_instruction ::= BRA bCC_tail
bcs_instruction ::= BCS bCC_tail
blo_instruction ::= BLO bCC_tail // == bcs
bls_instruction ::= BLS bCC_tail
beq_instruction ::= BEQ bCC_tail
bne_instruction ::= BNE bCC_tail
bhi_instruction ::= BHI bCC_tail
bcc_instruction ::= BCC bCC_tail
bhs_instruction ::= BHS bCC_tail // == bcc
bpl_instruction ::= BPL bCC_tail
bvc_instruction ::= BVC bCC_tail

blt_instruction ::= BLT bCC_tail
ble_instruction ::= BLE bCC_tail
bgt_instruction ::= BGT bCC_tail
bge_instruction ::= BGE bCC_tail
bmi_instruction ::= BMI bCC_tail
bvs_instruction ::= BVS bCC_tail


// DecrementAndBranch ==============================================
private dbCC_instructions ::= dbra_instruction |
                              dbcs_instruction |
                              dbls_instruction |
                              dbeq_instruction |
                              dbne_instruction |
                              dbhi_instruction |
                              dbcc_instruction |
                              dbpl_instruction |
                              dbvc_instruction |
                              dblt_instruction |
                              dble_instruction |
                              dbgt_instruction |
                              dbge_instruction |
                              dbmi_instruction |
                              dbvs_instruction |
                              dbf_instruction |
                              dbt_instruction

private dbCC_tail ::= CC_data_size? adm_drd COMMA expression

dbra_instruction ::= DBRA dbCC_tail
dbcs_instruction ::= DBCS dbCC_tail
dbls_instruction ::= DBLS dbCC_tail
dbeq_instruction ::= DBEQ dbCC_tail
dbne_instruction ::= DBNE dbCC_tail
dbhi_instruction ::= DBHI dbCC_tail
dbcc_instruction ::= DBCC dbCC_tail
dbpl_instruction ::= DBPL dbCC_tail
dbvc_instruction ::= DBVC dbCC_tail

dblt_instruction ::= DBLT dbCC_tail
dble_instruction ::= DBLE dbCC_tail
dbgt_instruction ::= DBGT dbCC_tail
dbge_instruction ::= DBGE dbCC_tail
dbmi_instruction ::= DBMI dbCC_tail
dbvs_instruction ::= DBVS dbCC_tail
dbf_instruction ::= DBF dbCC_tail
dbt_instruction ::= DBT dbCC_tail

// sCC instructions ========================================================
private sCC_instructions ::= seq_instruction |
                             sne_instruction |
                             spl_instruction |
                             smi_instruction |
                             svc_instruction |
                             svs_instruction |
                             st_instruction  |
                             sf_instruction  |
                             sge_instruction |
                             sgt_instruction |
                             sle_instruction |
                             slt_instruction |
                             scc_instruction |
                             shi_instruction |
                             sls_instruction |
                             scs_instruction

private sCC_tail ::= data_size_byte? (any_register | effective_address)

seq_instruction ::= SEQ sCC_tail
sne_instruction ::= SNE sCC_tail
spl_instruction ::= SPL sCC_tail
smi_instruction ::= SMI sCC_tail
svc_instruction ::= SVC sCC_tail
svs_instruction ::= SVS sCC_tail
st_instruction  ::= ST  sCC_tail
sf_instruction  ::= SF  sCC_tail
sge_instruction ::= SGE sCC_tail
sgt_instruction ::= SGT sCC_tail
sle_instruction ::= SLE sCC_tail
slt_instruction ::= SLT sCC_tail
scc_instruction ::= SCC sCC_tail
shi_instruction ::= SHI sCC_tail
sls_instruction ::= SLS sCC_tail
scs_instruction ::= SCS sCC_tail

// Bit =====================================================================
private bit_instructions ::= bchg_instruction |
                             bclr_instruction |
                             bset_instruction |
                             btst_instruction

fake bit_instruction_base ::= {
  extends = data_sized
}

private bit_data_size ::= data_size_byte | data_size_long {
  name = ".b|l"
}
private bit_tail ::= bit_data_size?
                     (immediate_data | data_register) COMMA (data_register | effective_address)

bchg_instruction ::= BCHG bit_tail {
  extends = bit_instruction_base
}
bclr_instruction ::= BCLR bit_tail {
  extends = bit_instruction_base
}
bset_instruction ::= BSET bit_tail {
  extends = bit_instruction_base
}
btst_instruction ::= BTST bit_tail {
  extends = bit_instruction_base
}


// Shift ===================================================================
private shift_instructions ::= asl_instruction |
                               asr_instruction |
                               lsl_instruction |
                               lsr_instruction |
                               rol_instruction |
                               ror_instruction |
                               roxl_instruction |
                               roxr_instruction

fake shift_instruction_base ::= {
  extends = data_sized
}

private shift_tail ::= data_size_all?
                       (immediate_data | data_register) COMMA (data_register | effective_address)

asl_instruction ::= ASL shift_tail {
  extends = shift_instruction_base
}
asr_instruction ::= ASR shift_tail {
  extends = shift_instruction_base
}

lsl_instruction ::= LSL shift_tail {
  extends = shift_instruction_base
}
lsr_instruction ::= LSR shift_tail {
  extends = shift_instruction_base
}

rol_instruction ::= ROL shift_tail {
  extends = shift_instruction_base
}
ror_instruction ::= ROR shift_tail {
  extends = shift_instruction_base
}

roxl_instruction ::= ROXL shift_tail {
  extends = shift_instruction_base
}
roxr_instruction ::= ROXR shift_tail {
  extends = shift_instruction_base
}


// Directives  ===================================================================
private directives ::= equ_directive |
                       blk_directive |
                       equals_directive |
                       equr_directive |
                       even_directive |
                       odd_directive |
                       incbin_directive |
                       incdir_directive |
                       include_directive |
                       dc_directive |
                       dcb_directive |
                       ds_directive |
                       rsset_directive |
                       rsreset_directive |
                       rs_directive |
                       opt_directive |
                       macro_directive |
                       endm_directive

fake equ_directive_base ::= label expression? {
//  implements = "com.intellij.psi.PsiNameIdentifierOwner"
//  methods = [  getNameIdentifier]
}
equ_directive ::= label EQU expression {
  pin = 2
  extends = equ_directive_base
}

equals_directive ::= label EQ expression {
  pin = 2
  extends = equ_directive_base
}

equr_directive ::= label EQUR adm_rrd {
  pin = 2
  extends = equ_directive_base   // todo doesn't make sense (expression != register)
}

even_directive ::= EVEN
odd_directive ::= ODD

private include_path ::= STRING {
  name = "include path"
}
incbin_directive ::= INCBIN include_path {
  pin =1
}
incdir_directive ::= INCDIR include_path {
  pin = 1
}
include_directive ::= INCLUDE include_path {
  pin = 1
}

private dc_element ::= expression
dc_directive ::= DC data_size_all? dc_element (COMMA dc_element)* {
  pin = 1
  extends = data_sized
}

dcb_directive ::= DCB data_size_all? expression (COMMA expression)? {
  pin = 1
  extends = data_sized
  methods = [
    expression = ""
    number = "expression[0]"
    value = "expression[1]"
  ]
}

ds_directive ::= DS data_size_all? expression {
  pin = 1
  extends = data_sized
}

rsset_directive ::= RSSET expression {
  pin = 1
}
rsreset_directive ::= RSRESET {
  pin = 1
}

rs_directive ::= RS data_size_all? expression {
  pin = 1
  extends = data_sized
}

blk_directive ::= BLK data_size_all? expression COMMA expression {
  pin = 1
  extends = data_sized
  methods = [
    expression = ""
    number = "expression[0]"
    value = "expression[1]"
  ]
}

private opt_element ::= ID (PLUS | MINUS) {
  pin = 1
  name = "option(+|-)"
}
opt_directive ::= OPT opt_element (COMMA opt_element)* {
  pin = 1
}

macro_directive ::= label MACRO
endm_directive ::= ENDM

// Expressions  ============================================================
;{
  extends("(plus|minus|mul|div|mod|exp|shift.*|or|and)_expression") = binary_expression
  extends(".*expression") = expression
  consumeTokenMethod(".*expression")="consumeTokenFast"
}

expression ::= add_group |
               mul_group |
               unary_group |
               exp_expression |
               shift_group |
               bool_group |
               primary_group

fake binary_expression ::= expression+ {
  methods = [
    expression = ""
    left = "/expression[0]"
    right = "/expression[1]"
  ]
  pin = 2
}

private add_group ::= plus_expression | minus_expression
plus_expression ::= expression PLUS expression
minus_expression ::= expression MINUS expression

private mul_group ::= mul_expression | div_expression | mod_expression
mul_expression ::= expression MUL expression
div_expression ::= expression DIV expression
mod_expression ::= expression PERCENT expression

private unary_group ::= unary_plus_expression | unary_minus_expression | unary_complement_expression
unary_plus_expression ::= PLUS expression
unary_minus_expression ::= MINUS expression
unary_complement_expression ::= TILDE expression

exp_expression ::= expression POW expression  // todo is this XOR?

private shift_group ::= shift_left_expression | shift_right_expression
shift_left_expression ::= expression SHIFT_L expression
shift_right_expression ::= expression SHIFT_R expression

private bool_group ::= or_expression | and_expression
or_expression ::= expression PIPE expression
and_expression ::= expression AMPERSAND expression

private primary_group ::= number_expression | string_expression | paren_expression | label_ref_expression
number_expression ::= DEC_NUMBER | HEX_NUMBER | OCT_NUMBER | BIN_NUMBER
string_expression ::= STRING

private plain_paren_expression ::= L_PAREN expression R_PAREN {
  pin = 1
}
private bracket_paren_expression ::= L_BRACKET expression R_BRACKET {
  pin = 1
}
paren_expression ::= plain_paren_expression | bracket_paren_expression

label_ref_expression ::= label_reference

