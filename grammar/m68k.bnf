/*
 * Copyright 2020 The Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 References:
 
 http://users.encs.concordia.ca/~aagarwal/coen311/motorola68000.txt
 http://www.easy68k.com/files/EASy68KQuickRef.pdf
 https://neo.dmcs.pl/pn/asembler_68000/asm.html
 https://github.com/marhel/r68k/blob/master/tools/src/assembler/parser.rs
*/

{
  parserClass = "com.yanncebron.m68kplugin.lang.M68kParser"
  parserImports = [
    "static com.yanncebron.m68kplugin.lang.psi.M68kTokenTypes.*"
  ]

  implements = "com.yanncebron.m68kplugin.lang.psi.M68kPsiElement"
  extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix = "M68k"
  psiImplClassSuffix = "Impl"
  psiPackage = "com.yanncebron.m68kplugin.lang.psi"
  psiImplPackage = "com.yanncebron.m68kplugin.lang.psi.impl"

  elementTypeHolderClass = "com.yanncebron.m68kplugin.lang.psi.M68kTypes"
  elementTypeClass = "com.yanncebron.m68kplugin.lang.psi.M68kCompositeElementType"

  psiImplUtilClass="com.yanncebron.m68kplugin.lang.psi.impl.M68kPsiImplUtil"

  classHeader = "license.txt"
  generate = [
    java="8"
    tokens = "no"
  ]
  
  pin(".*_instruction") = 1
  name(".*_instruction") = "instruction"
}

root ::= root_item*
private root_item ::= (instructions | labels)
{
  recoverWhile = root_item_recover
}
private root_item_recover ::= !(instructions | labels)
{
  consumeTokenMethod = "consumeTokenFast"
}
//private     crlf::='\n' // todo stop parsing after line?

private labels ::= label | localLabel

// todo must start on newline? usually not, but not required
// todo full name is: DevPac. prefixed with last non-local label
fake label_base ::= ID
{
  implements = "com.intellij.psi.PsiNamedElement"
  mixin = "com.yanncebron.m68kplugin.lang.psi.impl.M68kLabelBaseMixIn"
}

label ::= UNDERSCORE? ID COLON?
{
  extends = label_base
}

localLabel ::= DOT ID COLON?
{
  pin = 1
  name = "local label"
  extends = label_base
  mixin = "com.yanncebron.m68kplugin.lang.psi.impl.M68kLocalLabelBaseMixIn"
}

// todo sort instructions by frequency?
private instructions ::= directives |

                         move_instructions |

                         misc_instructions |

                         jump_instructions |

                         add_sub_instructions |
                         mul_div_instructions |
                         bcd_instructions|

                         cmp_instructions |

                         bool_instructions |
                         bit_instructions |
                         shift_instructions |

                         bCC_instructions |
                         dbCC_instructions |
                         sCC_instructions


// data size  _______=====================================================
fake data_sized ::=
{
  methods = [ getDataSize ]
}

private data_size_byte ::= DOT_B
private data_size_short ::= DOT_S
private data_size_word ::= DOT_W
private data_size_long ::= DOT_L
private data_size_word_long ::= data_size_word | data_size_long
{
  name = ".w|l"
}
private data_size_all ::= data_size_byte | data_size_word_long
{
  name = ".b|w|l"
}


// "d0-d7/a1/a4"
register_range ::= adm_rrd (MINUS adm_rrd)? {
  pin(".*") = 1
  methods = [
    adm_rrd= ""
    from = "adm_rrd[0]"
    to = "adm_rrd[1]"
  ]
}
register_list ::= register_range (DIV register_range)* {
  pin(".*") = 1
}


// addressing modes  =====================================================
// d0
adm_drd ::= DATA_REGISTER
{
  name = "data register"
}
// a0 | sp
adm_ard ::= ADDRESS_REGISTER | SP
{
  name = "address register"
}
// Rn
adm_rrd ::= adm_drd | adm_ard
{
  name = "data|address register"
}
// Rn[.bwl] used in adm_ix/adm_pci
adm_rrd_index ::= (adm_drd data_size_all?) | (adm_ard data_size_word_long?)
{
  name = "data|address register"
  extends = data_sized
}
// (a0)
adm_ari ::= L_PAREN adm_ard R_PAREN
// (a0)+
adm_api ::= L_PAREN adm_ard R_PAREN PLUS
// -(a0)
adm_apd ::= MINUS L_PAREN adm_ard R_PAREN
// index(a0)
adm_adi ::= expression L_PAREN adm_ard R_PAREN
// index(a0,d0)
adm_aix ::= expression L_PAREN adm_ard COMMA adm_rrd_index R_PAREN
// 4000 | 4000.w | 4000.l 
adm_abs ::= expression data_size_word_long?
// index(pc)
adm_pcd ::= expression L_PAREN PC R_PAREN
// index(pc,d0)
adm_pci ::= expression L_PAREN PC COMMA adm_rrd_index R_PAREN
// #4000 | #4000.w | #4000.l
adm_imm ::= HASH expression data_size_word_long?
{
  pin = 1
  name = "immediate data"
}

adm_sr ::= SR
adm_ccr ::= CCR
adm_usp ::= USP

// ATTN: ordering in groups
private adm_group_all ::=                   adm_drd | adm_ard | adm_imm | adm_api | adm_ari | adm_apd | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs
private adm_group_all_except_ard ::=        adm_drd |           adm_imm | adm_api | adm_ari | adm_apd | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs
private adm_group_all_except_pc_imm ::=     adm_drd | adm_ard |           adm_api | adm_ari | adm_apd | adm_adi | adm_aix | adm_abs
private adm_group_all_except_ard_pc_imm ::= adm_drd |                     adm_api | adm_ari | adm_apd | adm_adi | adm_aix | adm_abs


// Common tails
private tail_data_size_all___all__all_except_pc_imm ::=     data_size_all?       adm_group_all COMMA adm_group_all_except_pc_imm
{
  pin = 2
}
private tail_data_size_all___imm__all_except_ard_pc_imm ::= data_size_all?       adm_imm       COMMA adm_group_all_except_ard_pc_imm
{
  pin = 2
}
private tail_data_size_word_long___all__ard ::=             data_size_word_long? adm_group_all COMMA adm_ard
{
  pin = 2
}

private tail_data_size_all___all_except_ard_pc_imm ::=      data_size_all?       adm_group_all_except_ard_pc_imm


// Move ==================================================================
;
{
  extends("move.*_instruction") = move_instruction_base
}
private move_instructions ::= move_instruction |
                              movea_instruction |
                              moveq_instruction |
                              movem_instruction |
                              movep_instruction

fake move_instruction_base ::=
{
  extends = data_sized
}

private move_tail_usp_ard ::= data_size_long? adm_usp COMMA adm_ard
{
  pin = 2
}
private move_tail_ard_usp ::= data_size_long? adm_ard COMMA adm_usp
private move_tail_to_ccr_sr ::= data_size_word? adm_group_all_except_ard COMMA (adm_ccr | adm_sr)
private move_tail_sr ::= data_size_word? adm_sr COMMA adm_group_all_except_ard_pc_imm
{
  pin = 2
}
move_instruction ::= MOVE
                     (
                       move_tail_usp_ard |
                       move_tail_sr |
                       move_tail_to_ccr_sr |
                       move_tail_ard_usp |
                       tail_data_size_all___all__all_except_pc_imm
                     )

movea_instruction ::= MOVEA tail_data_size_word_long___all__ard

moveq_instruction ::= MOVEQ data_size_long?
                      adm_imm COMMA adm_drd
{
  methods = [
    source = "adm_imm"
    destination = "adm_drd"
  ]
}

movem_instruction ::= MOVEM data_size_word_long?
                      (
                        ( register_list COMMA (adm_ari | adm_apd | adm_adi | adm_aix | adm_abs) ) |
                        ( (adm_api | adm_ari | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs) COMMA register_list )
                      )

private movep_tail_drd_adi ::= adm_drd COMMA adm_adi
{
  pin = 1
}
private movep_tail_adi_drd ::= adm_adi COMMA adm_drd
{
  pin = 1
}
movep_instruction ::= MOVEP data_size_word_long?
                      (
                        movep_tail_drd_adi |
                        movep_tail_adi_drd
                      )


// Jump ==================================================================
private jump_instructions ::= jsr_instruction|
                              bsr_instruction |
                              jmp_instruction |
                              rts_instruction |
                              rte_instruction |
                              rtr_instruction

private bsr_data_size ::= (data_size_short | data_size_word)
{
  name = ".s|w"
}
bsr_instruction ::= BSR bsr_data_size? expression
{
  extends = data_sized
}

private jmp_jsr_tail ::= adm_ari | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs
jmp_instruction ::= JMP jmp_jsr_tail
jsr_instruction ::= JSR jmp_jsr_tail

rts_instruction ::= RTS
rte_instruction ::= RTE
rtr_instruction ::= RTR

// *bcd ==================================================================
;
{
  extends("(abcd|sbcd)_instruction") = bcd_instruction_base
}
private bcd_instructions ::= abcd_instruction |
                             nbcd_instruction |
                             sbcd_instruction
fake bcd_instruction_base ::=
{
  extends = data_sized
}

private bcd_tail_apd ::= adm_apd COMMA adm_apd
{
  pin = 1
}
private bcd_tail_drd ::= adm_drd COMMA adm_drd
{
  pin = 1
}
private bcd_tail ::= data_size_byte?
                     bcd_tail_drd | bcd_tail_apd

abcd_instruction ::= ABCD bcd_tail

sbcd_instruction ::= SBCD bcd_tail


nbcd_instruction ::= NBCD data_size_byte? adm_group_all_except_pc_imm
{
  extends = data_sized
}

// Add/Sub ==================================================================
private add_sub_instructions ::= add_instruction |
                                 adda_instruction |
                                 addi_instruction |
                                 addq_instruction |
                                 addx_instruction |
                                 sub_instruction |
                                 suba_instruction |
                                 subi_instruction |
                                 subq_instruction |
                                 subx_instruction

private add_sub_q_tail ::= data_size_all? adm_imm COMMA adm_group_all_except_pc_imm
{
  pin = 2
}

private add_sub_x_tail_drd_drd ::= adm_drd COMMA adm_drd
{
  pin = 1
}
private add_sub_x_tail_apd_apd ::= adm_apd COMMA adm_apd
{
  pin = 1
}
private add_sub_x_tail ::= data_size_all?
                           (
                             add_sub_x_tail_drd_drd |
                             add_sub_x_tail_apd_apd
                           )

add_instruction ::= ADD tail_data_size_all___all__all_except_pc_imm
adda_instruction ::= ADDA tail_data_size_word_long___all__ard
addi_instruction ::= ADDI tail_data_size_all___imm__all_except_ard_pc_imm
addq_instruction ::= ADDQ add_sub_q_tail
addx_instruction ::= ADDX add_sub_x_tail

sub_instruction ::= SUB tail_data_size_all___all__all_except_pc_imm
suba_instruction ::= SUBA tail_data_size_word_long___all__ard
subi_instruction ::= SUBI tail_data_size_all___imm__all_except_ard_pc_imm
subq_instruction ::= SUBQ add_sub_q_tail
subx_instruction ::= SUBX add_sub_x_tail


// Mul/Div ==================================================================
private mul_div_instructions ::= muls_instruction |
                                 mulu_instruction |
                                 divs_instruction |
                                 divu_instruction

private mul_div_tail ::= data_size_word?
                         adm_group_all_except_ard COMMA adm_drd
{
  pin = 2
}

muls_instruction ::= MULS mul_div_tail
mulu_instruction ::= MULU mul_div_tail
divs_instruction ::= DIVS mul_div_tail
divu_instruction ::= DIVU mul_div_tail


// Boolean ==================================================================
;
{
  extends("(and.*|or.*|eor.*|not)_instruction") = bool_instruction_base
}
private bool_instructions ::= and_instruction |
                              andi_instruction |
                              or_instruction |
                              ori_instruction |
                              eor_instruction |
                              eori_instruction |
                              not_instruction
fake bool_instruction_base ::=
{
  extends = data_sized
}

private bool_tail ::= data_size_all?
                      adm_group_all_except_ard COMMA adm_group_all_except_ard_pc_imm

private bool_i_tail_imm_ccr ::= data_size_byte? adm_imm COMMA adm_ccr
private bool_i_tail_imm_sr ::= data_size_word? adm_imm COMMA adm_sr 
private bool_i_tail ::= bool_i_tail_imm_ccr |
                        bool_i_tail_imm_sr |
                        tail_data_size_all___imm__all_except_ard_pc_imm

and_instruction ::= AND bool_tail
andi_instruction ::= ANDI bool_i_tail

or_instruction ::= OR bool_tail
ori_instruction ::= ORI bool_i_tail

eor_instruction ::= EOR bool_tail
eori_instruction ::= EORI bool_i_tail

not_instruction ::= NOT tail_data_size_all___all_except_ard_pc_imm


// Misc ==================================================================
private misc_instructions ::= tst_instruction |
                              tas_instruction |
                              lea_instruction |
                              pea_instruction |
                              clr_instruction |

                              nop_instruction |
                              illegal_instruction |
                              reset_instruction |
                              stop_instruction |
                              trap_instruction |
                              trapv_instruction |

                              link_instruction |
                              unlk_instruction |

                              ext_instruction |
                              neg_instruction |
                              negx_instruction |

                              swap_instruction |
                              chk_instruction |
                              exg_instruction

nop_instruction ::= NOP
illegal_instruction ::= ILLEGAL
reset_instruction ::= RESET
stop_instruction ::= STOP adm_imm
trap_instruction ::= TRAP adm_imm
trapv_instruction ::= TRAPV

link_instruction ::= LINK adm_ard COMMA adm_imm
unlk_instruction ::= UNLK adm_ard

lea_instruction ::= LEA data_size_long?
                    (adm_ard | adm_ari | adm_apd | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs) COMMA adm_ard
{
  extends = data_sized
}
pea_instruction ::= PEA data_size_long?
                    (adm_ari | adm_apd | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs)
{
  extends = data_sized
}

clr_instruction ::= CLR tail_data_size_all___all_except_ard_pc_imm
{
  extends = data_sized
}

tst_instruction ::= TST tail_data_size_all___all_except_ard_pc_imm
{
  extends = data_sized
}
tas_instruction ::= TAS data_size_byte? adm_group_all_except_ard_pc_imm
{
  extends = data_sized
}

ext_instruction ::= EXT data_size_word_long? adm_drd
{
  extends = data_sized
}

exg_instruction ::= EXG data_size_long? adm_rrd COMMA adm_rrd
{
  extends = data_sized
  methods = [
    adm_rrd = ""
    source = "adm_rrd[0]"
    destination = "adm_rrd[1]"
  ]
}

neg_instruction ::= NEG tail_data_size_all___all_except_ard_pc_imm
{
  extends = data_sized
}
negx_instruction ::= NEGX tail_data_size_all___all_except_ard_pc_imm
{
  extends = data_sized
}

swap_instruction ::= SWAP data_size_word? adm_drd
{
  extends = data_sized
}

chk_instruction ::= CHK data_size_word? adm_group_all_except_ard COMMA adm_drd
{
  extends = data_sized
}


// Compare ==================================================================
;
{
  extends("cmp.*_instruction") = cmp_instruction_base
}
private cmp_instructions ::= cmp_instruction |
                             cmpa_instruction |
                             cmpi_instruction |
                             cmpm_instruction
fake cmp_instruction_base ::=
{
  extends = data_sized
}

cmp_instruction ::= CMP tail_data_size_all___all__all_except_pc_imm

cmpa_instruction ::= CMPA tail_data_size_word_long___all__ard

cmpi_instruction ::= CMPI tail_data_size_all___imm__all_except_ard_pc_imm

cmpm_instruction ::= CMPM data_size_all?
                     adm_api COMMA adm_api
{
  methods = [
    adm_api = ""
    source = "adm_api[0]"
    destination = "adm_api[1]"
  ]
}


// Branch ==================================================================
private CC_data_size ::= (data_size_all | data_size_short)
{
  name = ".s|b|w|l"
}

private bCC_instructions ::= bra_instruction |
                             bcs_instruction |
                             blo_instruction |
                             bls_instruction |
                             beq_instruction |
                             bne_instruction |
                             bhi_instruction |
                             bcc_instruction |
                             bhs_instruction |
                             bpl_instruction |
                             bvc_instruction |
                             blt_instruction |
                             ble_instruction |
                             bgt_instruction |
                             bge_instruction |
                             bmi_instruction |
                             bvs_instruction

private bCC_tail ::= CC_data_size? expression

bra_instruction ::= BRA bCC_tail
bcs_instruction ::= BCS bCC_tail
blo_instruction ::= BLO bCC_tail // == bcs
bls_instruction ::= BLS bCC_tail
beq_instruction ::= BEQ bCC_tail
bne_instruction ::= BNE bCC_tail
bhi_instruction ::= BHI bCC_tail
bcc_instruction ::= BCC bCC_tail
bhs_instruction ::= BHS bCC_tail // == bcc
bpl_instruction ::= BPL bCC_tail
bvc_instruction ::= BVC bCC_tail

blt_instruction ::= BLT bCC_tail
ble_instruction ::= BLE bCC_tail
bgt_instruction ::= BGT bCC_tail
bge_instruction ::= BGE bCC_tail
bmi_instruction ::= BMI bCC_tail
bvs_instruction ::= BVS bCC_tail


// DecrementAndBranch ==============================================
private dbCC_instructions ::= dbra_instruction |
                              dbcs_instruction |
                              dbls_instruction |
                              dbeq_instruction |
                              dbne_instruction |
                              dbhi_instruction |
                              dbcc_instruction |
                              dbpl_instruction |
                              dbvc_instruction |
                              dblt_instruction |
                              dble_instruction |
                              dbgt_instruction |
                              dbge_instruction |
                              dbmi_instruction |
                              dbvs_instruction |
                              dbf_instruction |
                              dbt_instruction

private dbCC_tail ::= CC_data_size? adm_drd COMMA expression
{
  pin = 2
}

dbra_instruction ::= DBRA dbCC_tail
dbcs_instruction ::= DBCS dbCC_tail
dbls_instruction ::= DBLS dbCC_tail
dbeq_instruction ::= DBEQ dbCC_tail
dbne_instruction ::= DBNE dbCC_tail
dbhi_instruction ::= DBHI dbCC_tail
dbcc_instruction ::= DBCC dbCC_tail
dbpl_instruction ::= DBPL dbCC_tail
dbvc_instruction ::= DBVC dbCC_tail

dblt_instruction ::= DBLT dbCC_tail
dble_instruction ::= DBLE dbCC_tail
dbgt_instruction ::= DBGT dbCC_tail
dbge_instruction ::= DBGE dbCC_tail
dbmi_instruction ::= DBMI dbCC_tail
dbvs_instruction ::= DBVS dbCC_tail
dbf_instruction ::= DBF dbCC_tail
dbt_instruction ::= DBT dbCC_tail

// sCC instructions ========================================================
private sCC_instructions ::= seq_instruction |
                             sne_instruction |
                             spl_instruction |
                             smi_instruction |
                             svc_instruction |
                             svs_instruction |
                             st_instruction  |
                             sf_instruction  |
                             sge_instruction |
                             sgt_instruction |
                             sle_instruction |
                             slt_instruction |
                             scc_instruction |
                             shi_instruction |
                             sls_instruction |
                             scs_instruction

private sCC_tail ::= data_size_byte? adm_group_all_except_ard_pc_imm

seq_instruction ::= SEQ sCC_tail
sne_instruction ::= SNE sCC_tail
spl_instruction ::= SPL sCC_tail
smi_instruction ::= SMI sCC_tail
svc_instruction ::= SVC sCC_tail
svs_instruction ::= SVS sCC_tail
st_instruction  ::= ST  sCC_tail
sf_instruction  ::= SF  sCC_tail
sge_instruction ::= SGE sCC_tail
sgt_instruction ::= SGT sCC_tail
sle_instruction ::= SLE sCC_tail
slt_instruction ::= SLT sCC_tail
scc_instruction ::= SCC sCC_tail
shi_instruction ::= SHI sCC_tail
sls_instruction ::= SLS sCC_tail
scs_instruction ::= SCS sCC_tail

// Bit =====================================================================
;
{
  extends("(bchg|bclr|bset|btst)_instruction") = bit_instruction_base
}
private bit_instructions ::= bchg_instruction |
                             bclr_instruction |
                             bset_instruction |
                             btst_instruction

fake bit_instruction_base ::=
{
  extends = data_sized
}

private bit_data_size ::= data_size_byte | data_size_long
{
  name = ".b|l"
}
private bit_tail ::= bit_data_size?
                     (adm_drd | adm_imm) COMMA adm_group_all_except_ard_pc_imm

bchg_instruction ::= BCHG bit_tail

bclr_instruction ::= BCLR bit_tail

bset_instruction ::= BSET bit_tail

btst_instruction ::= BTST bit_data_size?
                     (adm_drd | adm_imm) COMMA adm_group_all_except_ard


// Shift ===================================================================
;
{
  extends("(as.*|ls.*|ro.*)_instruction") = shift_instruction_base
}
private shift_instructions ::= asl_instruction |
                               asr_instruction |
                               lsl_instruction |
                               lsr_instruction |
                               rol_instruction |
                               ror_instruction |
                               roxl_instruction |
                               roxr_instruction

fake shift_instruction_base ::=
{
  extends = data_sized
}

private shift_tail ::=
  (
    ( data_size_all?
      (adm_drd | adm_imm) COMMA adm_drd
    ) |
    ( data_size_word?
      (adm_api | adm_ari | adm_apd | adm_adi | adm_aix | adm_abs)
    )
  )

asl_instruction ::= ASL shift_tail
asr_instruction ::= ASR shift_tail

lsl_instruction ::= LSL shift_tail
lsr_instruction ::= LSR shift_tail

rol_instruction ::= ROL shift_tail
ror_instruction ::= ROR shift_tail

roxl_instruction ::= ROXL shift_tail
roxr_instruction ::= ROXR shift_tail


// Directives  ===================================================================
;
{
  parserClass = "com.yanncebron.m68kplugin.lang.M68kDirectivesParser"
}

private directives ::= equ_directive |
                       blk_directive |
                       equals_directive |
                       set_directive |
                       equr_directive |
                       even_directive |
                       odd_directive |
                       incbin_directive |
                       incdir_directive |
                       include_directive |
                       dc_directive |
                       dcb_directive |
                       ds_directive |
                       rsset_directive |
                       rsreset_directive |
                       rs_directive |
                       opt_directive |
                       org_directive |
                       macro_directive |
                       endm_directive |
                       end_directive |
                       conditional_assembly_directives

fake equ_directive_base ::= label expression?
{
//  implements = "com.intellij.psi.PsiNameIdentifierOwner"
//  methods = [  getNameIdentifier]
}
equ_directive ::= label EQU expression
{
  pin = 2
  extends = equ_directive_base
}

equals_directive ::= label EQ expression
{
  pin = 2
  extends = equ_directive_base
}

set_directive ::= label SET expression
{
  pin = 2
  extends = equ_directive_base
}

equr_directive ::= label EQUR adm_rrd
{
  pin = 2
  extends = equ_directive_base   // todo doesn't make sense (expression != register)
}

even_directive ::= EVEN
odd_directive ::= ODD

end_directive ::= END

private include_path ::= STRING
{
  name = "include path"
}
incbin_directive ::= INCBIN include_path
{
  pin =1
}
incdir_directive ::= INCDIR include_path
{
  pin = 1
}
include_directive ::= INCLUDE include_path
{
  pin = 1
}

dc_directive ::= DC data_size_all? expression (COMMA expression)*
{
  pin = 1
  extends = data_sized
}

dcb_directive ::= DCB data_size_all? expression (COMMA expression)?
{
  pin = 1
  extends = data_sized
  methods = [
    expression = ""
    number = "expression[0]"
    value = "expression[1]"
  ]
}

ds_directive ::= DS data_size_all? expression
{
  pin = 1
  extends = data_sized
}

rsset_directive ::= RSSET expression
{
  pin = 1
}
rsreset_directive ::= RSRESET
{
  pin = 1
}

rs_directive ::= RS data_size_all? expression
{
  pin = 1
  extends = data_sized
}

blk_directive ::= BLK data_size_all? expression COMMA expression
{
  pin = 1
  extends = data_sized
  methods = [
    expression = ""
    number = "expression[0]"
    value = "expression[1]"
  ]
}

private opt_element ::= ID (PLUS | MINUS)
{
  pin = 1
  name = "option(+|-)"
}
opt_directive ::= OPT opt_element (COMMA opt_element)*
{
  pin = 1
}

org_directive ::= ORG expression
{
  pin = 1
}

macro_directive ::= label MACRO
endm_directive ::= ENDM

;
{
  pin("if.*_directive") = 1
}
private conditional_assembly_directives ::= ifd_directive |
                                            ifeq_directive |
                                            ifge_directive |
                                            ifgt_directive |
                                            ifnd_directive |
                                            ifle_directive |
                                            iflt_directive |
                                            ifne_directive |
                                            else_directive |
                                            elseif_directive |
                                            endc_directive

ifd_directive ::= IFD expression
ifnd_directive ::= IFND expression

ifeq_directive ::= IFEQ expression
ifge_directive ::= IFGE expression
ifgt_directive ::= IFGT expression
ifle_directive ::= IFLE expression
iflt_directive ::= IFLT expression
ifne_directive ::= IFNE expression

elseif_directive ::= ELSEIF
else_directive ::= ELSE
endc_directive ::= ENDC


// Expressions  ============================================================
;{
  parserClass = "com.yanncebron.m68kplugin.lang.M68kExpressionParser"
  extends("(plus|minus|mul|div|mod|exp|shift.*|or|and)_expression") = binary_expression
  extends(".*expression") = expression
  consumeTokenMethod(".*expression")="consumeTokenFast"
}

expression ::= add_group |
               mul_group |
               unary_group |
               exp_expression |
               shift_group |
               bool_group |
               primary_group

fake binary_expression ::= expression+
{
  methods = [
    expression = ""
    left = "/expression[0]"
    right = "/expression[1]"
  ]
  pin = 2
}

private add_group ::= plus_expression | minus_expression
plus_expression ::= expression PLUS expression
minus_expression ::= expression MINUS expression

private mul_group ::= mul_expression | div_expression | mod_expression
mul_expression ::= expression MUL expression
div_expression ::= expression DIV expression
mod_expression ::= expression PERCENT expression

private unary_group ::= unary_plus_expression | unary_minus_expression | unary_complement_expression
unary_plus_expression ::= PLUS expression
unary_minus_expression ::= MINUS expression
unary_complement_expression ::= TILDE expression

exp_expression ::= expression POW expression  // todo is this XOR?

private shift_group ::= shift_left_expression | shift_right_expression
shift_left_expression ::= expression SHIFT_L expression
shift_right_expression ::= expression SHIFT_R expression

private bool_group ::= or_expression | and_expression
or_expression ::= expression PIPE expression
and_expression ::= expression AMPERSAND expression

private primary_group ::= number_expression | string_expression | paren_expression | label_ref_expression
number_expression ::= DEC_NUMBER | HEX_NUMBER | OCT_NUMBER | BIN_NUMBER
string_expression ::= STRING

private plain_paren_expression ::= L_PAREN expression R_PAREN
{
  pin = 1
}
private bracket_paren_expression ::= L_BRACKET expression R_BRACKET
{
  pin = 1
}
paren_expression ::= plain_paren_expression | bracket_paren_expression

label_ref_expression ::= ID
{
  mixin = "com.yanncebron.m68kplugin.lang.psi.impl.M68kLabelRefExpressionMixIn"
  name = "label"
}

