/*
 * Copyright 2020 The Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

{
  parserClass = "com.yanncebron.m68kplugin.lang.M68kParser"
  parserImports = [
    "static com.yanncebron.m68kplugin.lang.psi.M68kTokenTypes.*"
  ]
  parserUtilClass="com.yanncebron.m68kplugin.lang.M68kParserUtil"

  implements = "com.yanncebron.m68kplugin.lang.psi.M68kPsiElement"
  extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix = "M68k"
  psiImplClassSuffix = "Impl"
  psiPackage = "com.yanncebron.m68kplugin.lang.psi"
  psiImplPackage = "com.yanncebron.m68kplugin.lang.psi.impl"

  elementTypeHolderClass = "com.yanncebron.m68kplugin.lang.psi.M68kTypes"
  elementTypeClass = "com.yanncebron.m68kplugin.lang.psi.M68kCompositeElementType"

  psiImplUtilClass="com.yanncebron.m68kplugin.lang.psi.impl.M68kPsiImplUtil"

  classHeader = "license.txt"
  generate = [
    java = "8"
    tokens = "no"
  ]
  

  pin(".*_instruction") = 1
  name(".*_instruction") = "instruction"
  implements(".*_instruction.*") = "com.yanncebron.m68kplugin.lang.psi.M68kInstruction"
}

root ::= root_item*

private line_feed ::= LINEFEED+
{
  consumeTokenMethod = "consumeTokenFast"
}
private instruction_or_label ::= instructions | labels

private root_item ::= line_feed | instruction_or_label line_feed?
{
  recoverWhile = root_item_recover
}
private root_item_recover ::= !instruction_or_label
{
  consumeTokenMethod = "consumeTokenFast"
}

private labels ::= label | localLabel

private labelIdentifier ::= ID COLON?
{
  name = "label identifier"
}

// todo must start on newline? usually not, but not required
label ::= !<<afterWhitespace>> labelIdentifier
{
  implements = "com.yanncebron.m68kplugin.lang.psi.M68kLabelBase"
  mixin = "com.yanncebron.m68kplugin.lang.psi.impl.M68kLabelMixIn"
  elementTypeFactory = "com.yanncebron.m68kplugin.lang.stubs.M68kStubElementTypeFactory.stubFactory"
  stubClass = "com.yanncebron.m68kplugin.lang.stubs.M68kLabelStub"
  methods = [
    getLocalLabels
  ]
}

// todo full name is: DevPac. prefixed with last non-local label
localLabel ::= !<<afterWhitespace>> DOT labelIdentifier
{
  pin = 2
  name = "local label"
  implements = "com.yanncebron.m68kplugin.lang.psi.M68kLabelBase"
  mixin = "com.yanncebron.m68kplugin.lang.psi.impl.M68kLocalLabelMixIn"
}

private instructions ::= move_instructions |
                         data_movement_instructions |
                         jump_instructions |

                         add_sub_instructions |
                         mul_div_instructions |
                         bcd_instructions|

                         misc_instructions |

                         cmp_instructions |

                         logical_operation_instructions |
                         bit_manipulation_instructions |
                         shift_rotate_instructions |

                         bCC_instructions |
                         dbCC_instructions |
                         sCC_instructions |

                         directives |
                         conditional_assembly_directives


// data size  _______=====================================================
fake data_sized ::=
{
  methods = [ getDataSize ]
}

private data_size_byte ::= !<<afterWhitespace>> DOT_B
private data_size_short ::= !<<afterWhitespace>> DOT_S
private data_size_word ::= !<<afterWhitespace>> DOT_W
private data_size_long ::= !<<afterWhitespace>> DOT_L
private data_size_word_long ::= data_size_word | data_size_long
{
  name = ".w|l"
}
private data_size_all ::= data_size_byte | data_size_word_long
{
  name = ".b|w|l"
}


// "d0-d7/a1/a4"
register_range ::= adm_rrd (MINUS adm_rrd)? {
  pin(".*") = 1
  methods = [
    adm_rrd= ""
    from = "adm_rrd[0]"
    to = "adm_rrd[1]"
    getRegisters
  ]
}
register_list ::= register_range (DIV register_range)* {
  pin(".*") = 1
}


// addressing modes  =====================================================

// d0
adm_drd ::= DATA_REGISTER
{
  name = "data register"
  methods = [
    getRegister
  ]
}

// a0 | sp
adm_ard ::= ADDRESS_REGISTER | SP
{
  name = "address register"
  methods = [
    getRegister
  ]
}

// R0
adm_rrd ::= adm_drd | adm_ard
{
  name = "data|address register"
  methods = [
    getRegister
  ]
}

// R0[.bwl] used in adm_ix/adm_pci
adm_rrd_index ::= (adm_drd data_size_all?) | (adm_ard data_size_word_long?)
{
  name = "data|address register"
  methods = [
    getRegister
  ]
  extends = data_sized
}

// (a0)
adm_ari ::= L_PAREN adm_ard R_PAREN
{
  methods = [
    getRegister
  ]
}

// (a0)+
adm_api ::= L_PAREN adm_ard R_PAREN PLUS
{
  methods = [
    getRegister
  ]
}

// -(a0)
adm_apd ::= MINUS L_PAREN adm_ard R_PAREN
{
  methods = [
    getRegister
  ]
}

// index(a0)
adm_adi ::= expression L_PAREN adm_ard R_PAREN
{
  methods = [
    getRegister
  ]
}

// index(a0,d0)
adm_aix ::= expression? L_PAREN adm_ard COMMA adm_rrd_index R_PAREN
{
  pin = "COMMA"
  name = "expression"
}

// 4000 | 4000.w | 4000.l
adm_abs ::= expression data_size_word_long?

// index(pc)
adm_pcd ::= expression L_PAREN PC R_PAREN

// index(pc,d0)
adm_pci ::= expression? L_PAREN PC COMMA adm_rrd_index R_PAREN
{
  pin = "COMMA"
  name = "expression"
}

// #4000 | #4000.w | #4000.l
adm_imm ::= HASH expression data_size_word_long?
{
  pin = 1
  name = "immediate data"
}

adm_sr ::= SR
adm_ccr ::= CCR
adm_usp ::= USP

// ATTN: ordering in groups
private adm_group_all ::=                   adm_drd | adm_ard | adm_imm | adm_api | adm_ari | adm_apd | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs
private adm_group_all_except_ard ::=        adm_drd |           adm_imm | adm_api | adm_ari | adm_apd | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs
private adm_group_all_except_pc_imm ::=     adm_drd | adm_ard |           adm_api | adm_ari | adm_apd | adm_adi | adm_aix | adm_abs
private adm_group_all_except_ard_pc_imm ::= adm_drd |                     adm_api | adm_ari | adm_apd | adm_adi | adm_aix | adm_abs


// Common tails
private tail_data_size_all___all__all_except_pc_imm ::=     data_size_all?       adm_group_all COMMA adm_group_all_except_pc_imm
{
  pin = 2
}
private tail_data_size_all___imm__all_except_ard_pc_imm ::= data_size_all?       adm_imm       COMMA adm_group_all_except_ard_pc_imm
{
  pin = 2
}
private tail_data_size_word_long___all__ard ::=             data_size_word_long? adm_group_all COMMA adm_ard
{
  pin = 2
}

private tail_data_size_all___all_except_ard_pc_imm ::=      data_size_all?       adm_group_all_except_ard_pc_imm


// Move ==================================================================
;
{
  extends("move.*_instruction") = move_instruction_base
}
private move_instructions ::= move_instruction |
                              movea_instruction |
                              moveq_instruction |
                              movem_instruction |
                              movep_instruction

fake move_instruction_base ::=
{
  extends = data_sized
}

private move_tail_usp_ard ::= data_size_long? adm_usp COMMA adm_ard
{
  pin = 2
}
private move_tail_ard_usp ::= data_size_long? adm_ard COMMA adm_usp
private move_tail_to_ccr_sr ::= data_size_word? adm_group_all_except_ard COMMA (adm_ccr | adm_sr)
private move_tail_sr ::= data_size_word? adm_sr COMMA adm_group_all_except_ard_pc_imm
{
  pin = 2
}
move_instruction ::= MOVE
                     (
                       move_tail_usp_ard |
                       move_tail_sr |
                       move_tail_to_ccr_sr |
                       move_tail_ard_usp |
                       tail_data_size_all___all__all_except_pc_imm
                     )
{
  mixin = "com.yanncebron.m68kplugin.lang.psi.impl.M68kMoveInstructionMixIn"
}

movea_instruction ::= MOVEA tail_data_size_word_long___all__ard

moveq_instruction ::= MOVEQ data_size_long?
                      adm_imm COMMA adm_drd
{
  methods = [
    source = "adm_imm"
    destination = "adm_drd"
  ]
}

private movem_from_tail ::= register_list COMMA (adm_ari | adm_apd | adm_adi | adm_aix | adm_abs)
{
  pin = 1
}
private movem_to_tail ::= (adm_api | adm_ari | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs) COMMA register_list
{
  pin = 1
}
movem_instruction ::= MOVEM data_size_word_long?
                      (
                         movem_from_tail  |
                         movem_to_tail
                      )

private movep_tail_drd_adi ::= adm_drd COMMA adm_adi
{
  pin = 1
}
private movep_tail_adi_drd ::= adm_adi COMMA adm_drd
{
  pin = 1
}
movep_instruction ::= MOVEP data_size_word_long?
                      (
                        movep_tail_drd_adi |
                        movep_tail_adi_drd
                      )


// Data Movement =========================================================
private data_movement_instructions ::= exg_instruction |
                                       lea_instruction |
                                       pea_instruction |
                                       link_instruction |
                                       unlk_instruction


exg_instruction ::= EXG data_size_long? adm_rrd COMMA adm_rrd
{
  extends = data_sized
  methods = [
    adm_rrd = ""
    source = "adm_rrd[0]"
    destination = "adm_rrd[1]"
  ]
}

lea_instruction ::= LEA data_size_long?
                    (adm_ard | adm_ari | adm_apd | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs) COMMA adm_ard
{
  extends = data_sized
}
pea_instruction ::= PEA data_size_long?
                    (adm_ari | adm_apd | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs)
{
  extends = data_sized
}

link_instruction ::= LINK adm_ard COMMA adm_imm
unlk_instruction ::= UNLK adm_ard


// Jump ==================================================================
private jump_instructions ::= jsr_instruction|
                              bsr_instruction |
                              jmp_instruction |
                              rts_instruction |
                              rte_instruction |
                              rtr_instruction

private bsr_data_size ::= (data_size_short | data_size_byte | data_size_word)
{
  name = ".s|b|w"
}
bsr_instruction ::= BSR bsr_data_size? expression
{
  extends = data_sized
}

private jmp_jsr_tail ::= adm_ari | adm_pcd | adm_pci | adm_adi | adm_aix | adm_abs
jmp_instruction ::= JMP jmp_jsr_tail
jsr_instruction ::= JSR jmp_jsr_tail

rts_instruction ::= RTS
rte_instruction ::= RTE
{
  mixin = "com.yanncebron.m68kplugin.lang.psi.impl.M68kPrivilegedInstructionMixIn"
}

rtr_instruction ::= RTR

// *bcd ==================================================================
;
{
  extends("(abcd|sbcd)_instruction") = bcd_instruction_base
}
private bcd_instructions ::= abcd_instruction |
                             nbcd_instruction |
                             sbcd_instruction
fake bcd_instruction_base ::=
{
  extends = data_sized
}

private bcd_tail_apd ::= adm_apd COMMA adm_apd
{
  pin = 1
}
private bcd_tail_drd ::= adm_drd COMMA adm_drd
{
  pin = 1
}
private bcd_tail ::= data_size_byte?
                     (
                       bcd_tail_drd | bcd_tail_apd
                     )

abcd_instruction ::= ABCD bcd_tail

sbcd_instruction ::= SBCD bcd_tail


nbcd_instruction ::= NBCD data_size_byte? adm_group_all_except_pc_imm
{
  extends = data_sized
}

// Add/Sub ==================================================================
private add_sub_instructions ::= add_instruction |
                                 adda_instruction |
                                 addi_instruction |
                                 addq_instruction |
                                 addx_instruction |
                                 sub_instruction |
                                 suba_instruction |
                                 subi_instruction |
                                 subq_instruction |
                                 subx_instruction

private add_sub_q_tail ::= data_size_all? adm_imm COMMA adm_group_all_except_pc_imm
{
  pin = 2
}

private add_sub_x_tail_drd_drd ::= adm_drd COMMA adm_drd
{
  pin = 1
}
private add_sub_x_tail_apd_apd ::= adm_apd COMMA adm_apd
{
  pin = 1
}
private add_sub_x_tail ::= data_size_all?
                           (
                             add_sub_x_tail_drd_drd |
                             add_sub_x_tail_apd_apd
                           )

add_instruction ::= ADD tail_data_size_all___all__all_except_pc_imm
adda_instruction ::= ADDA tail_data_size_word_long___all__ard
addi_instruction ::= ADDI tail_data_size_all___imm__all_except_ard_pc_imm
addq_instruction ::= ADDQ add_sub_q_tail
addx_instruction ::= ADDX add_sub_x_tail

sub_instruction ::= SUB tail_data_size_all___all__all_except_pc_imm
suba_instruction ::= SUBA tail_data_size_word_long___all__ard
subi_instruction ::= SUBI tail_data_size_all___imm__all_except_ard_pc_imm
subq_instruction ::= SUBQ add_sub_q_tail
subx_instruction ::= SUBX add_sub_x_tail


// Mul/Div ==================================================================
private mul_div_instructions ::= muls_instruction |
                                 mulu_instruction |
                                 divs_instruction |
                                 divu_instruction

private mul_div_tail ::= data_size_word?
                         adm_group_all_except_ard COMMA adm_drd
{
  pin = 2
}

muls_instruction ::= MULS mul_div_tail
mulu_instruction ::= MULU mul_div_tail
divs_instruction ::= DIVS mul_div_tail
divu_instruction ::= DIVU mul_div_tail


// Boolean ==================================================================
;
{
  extends("(and|andi|or|ori|eor|eori)_instruction") = bool_instruction_base
}
private logical_operation_instructions ::= and_instruction |
                                           andi_instruction |
                                           or_instruction |
                                           ori_instruction |
                                           eor_instruction |
                                           eori_instruction |
                                           not_instruction
fake bool_instruction_base ::= bool_tail
{
  extends = data_sized
  mixin = "com.yanncebron.m68kplugin.lang.psi.impl.M68kBoolInstructionBaseMixIn"
}

private bool_tail ::= data_size_all?
                      adm_group_all_except_ard COMMA (adm_group_all_except_ard_pc_imm | adm_ccr | adm_sr)

private bool_i_tail_imm_ccr ::= data_size_byte? adm_imm COMMA adm_ccr
private bool_i_tail_imm_sr ::= data_size_word? adm_imm COMMA adm_sr
private bool_i_tail ::= (
                          bool_i_tail_imm_ccr |
                          bool_i_tail_imm_sr |
                          tail_data_size_all___imm__all_except_ard_pc_imm
                        )

and_instruction ::= AND bool_tail
andi_instruction ::= ANDI bool_i_tail

or_instruction ::= OR bool_tail
ori_instruction ::= ORI bool_i_tail

eor_instruction ::= EOR bool_tail
eori_instruction ::= EORI bool_i_tail

not_instruction ::= NOT tail_data_size_all___all_except_ard_pc_imm
{
  extends = data_sized
}


// Misc ==================================================================
private misc_instructions ::= tst_instruction |
                              tas_instruction |
                              clr_instruction |

                              nop_instruction |
                              illegal_instruction |
                              reset_instruction |
                              stop_instruction |
                              trap_instruction |
                              trapv_instruction |


                              ext_instruction |
                              neg_instruction |
                              negx_instruction |

                              swap_instruction |
                              chk_instruction

nop_instruction ::= NOP
illegal_instruction ::= ILLEGAL
reset_instruction ::= RESET
{
  mixin = "com.yanncebron.m68kplugin.lang.psi.impl.M68kPrivilegedInstructionMixIn"
}
stop_instruction ::= STOP adm_imm
{
  mixin = "com.yanncebron.m68kplugin.lang.psi.impl.M68kPrivilegedInstructionMixIn"
}
trap_instruction ::= TRAP adm_imm
trapv_instruction ::= TRAPV

clr_instruction ::= CLR tail_data_size_all___all_except_ard_pc_imm
{
  extends = data_sized
}

tst_instruction ::= TST tail_data_size_all___all_except_ard_pc_imm
{
  extends = data_sized
}
tas_instruction ::= TAS data_size_byte? adm_group_all_except_ard_pc_imm
{
  extends = data_sized
}

ext_instruction ::= EXT data_size_word_long? adm_drd
{
  extends = data_sized
}

neg_instruction ::= NEG tail_data_size_all___all_except_ard_pc_imm
{
  extends = data_sized
}
negx_instruction ::= NEGX tail_data_size_all___all_except_ard_pc_imm
{
  extends = data_sized
}

swap_instruction ::= SWAP data_size_word? adm_drd
{
  extends = data_sized
}

chk_instruction ::= CHK data_size_word? adm_group_all_except_ard COMMA adm_drd
{
  extends = data_sized
}


// Compare ==================================================================
;
{
  extends("cmp.*_instruction") = cmp_instruction_base
}
private cmp_instructions ::= cmp_instruction |
                             cmpa_instruction |
                             cmpi_instruction |
                             cmpm_instruction
fake cmp_instruction_base ::=
{
  extends = data_sized
}

cmp_instruction ::= CMP tail_data_size_all___all__all_except_pc_imm

cmpa_instruction ::= CMPA tail_data_size_word_long___all__ard

cmpi_instruction ::= CMPI tail_data_size_all___imm__all_except_ard_pc_imm

cmpm_instruction ::= CMPM data_size_all?
                     adm_api COMMA adm_api
{
  methods = [
    adm_api = ""
    source = "adm_api[0]"
    destination = "adm_api[1]"
  ]
}


// Branch ==================================================================
private CC_data_size ::= (data_size_all | data_size_short)
{
  name = ".s|b|w|l"
}

private bCC_instructions ::= bra_instruction |
                             bcs_instruction |
                             blo_instruction |
                             bls_instruction |
                             beq_instruction |
                             bne_instruction |
                             bhi_instruction |
                             bcc_instruction |
                             bhs_instruction |
                             bpl_instruction |
                             bvc_instruction |
                             blt_instruction |
                             ble_instruction |
                             bgt_instruction |
                             bge_instruction |
                             bmi_instruction |
                             bvs_instruction

private bCC_tail ::= CC_data_size? expression

bra_instruction ::= BRA bCC_tail
bcs_instruction ::= BCS bCC_tail
blo_instruction ::= BLO bCC_tail // == bcs
bls_instruction ::= BLS bCC_tail
beq_instruction ::= BEQ bCC_tail
bne_instruction ::= BNE bCC_tail
bhi_instruction ::= BHI bCC_tail
bcc_instruction ::= BCC bCC_tail
bhs_instruction ::= BHS bCC_tail // == bcc
bpl_instruction ::= BPL bCC_tail
bvc_instruction ::= BVC bCC_tail

blt_instruction ::= BLT bCC_tail
ble_instruction ::= BLE bCC_tail
bgt_instruction ::= BGT bCC_tail
bge_instruction ::= BGE bCC_tail
bmi_instruction ::= BMI bCC_tail
bvs_instruction ::= BVS bCC_tail


// DecrementAndBranch ==============================================
private dbCC_instructions ::= dbra_instruction |
                              dbcs_instruction |
                              dblo_instruction |
                              dbls_instruction |
                              dbeq_instruction |
                              dbne_instruction |
                              dbhi_instruction |
                              dbcc_instruction |
                              dbhs_instruction |
                              dbpl_instruction |
                              dbvc_instruction |
                              dblt_instruction |
                              dble_instruction |
                              dbgt_instruction |
                              dbge_instruction |
                              dbmi_instruction |
                              dbvs_instruction |
                              dbf_instruction |
                              dbt_instruction

private dbCC_tail ::= CC_data_size? adm_drd COMMA expression
{
  pin = 2
}

dbra_instruction ::= DBRA dbCC_tail
dbcs_instruction ::= DBCS dbCC_tail
dblo_instruction ::= DBLO dbCC_tail // == dbcs
dbls_instruction ::= DBLS dbCC_tail
dbeq_instruction ::= DBEQ dbCC_tail
dbne_instruction ::= DBNE dbCC_tail
dbhi_instruction ::= DBHI dbCC_tail
dbcc_instruction ::= DBCC dbCC_tail
dbhs_instruction ::= DBHS dbCC_tail // == dbcc
dbpl_instruction ::= DBPL dbCC_tail
dbvc_instruction ::= DBVC dbCC_tail

dblt_instruction ::= DBLT dbCC_tail
dble_instruction ::= DBLE dbCC_tail
dbgt_instruction ::= DBGT dbCC_tail
dbge_instruction ::= DBGE dbCC_tail
dbmi_instruction ::= DBMI dbCC_tail
dbvs_instruction ::= DBVS dbCC_tail
dbf_instruction ::= DBF dbCC_tail
dbt_instruction ::= DBT dbCC_tail

// sCC instructions ========================================================
private sCC_instructions ::= seq_instruction |
                             sne_instruction |
                             spl_instruction |
                             smi_instruction |
                             svc_instruction |
                             svs_instruction |
                             st_instruction  |
                             sf_instruction  |
                             sge_instruction |
                             sgt_instruction |
                             sle_instruction |
                             slt_instruction |
                             scc_instruction |
                             shi_instruction |
                             sls_instruction |
                             scs_instruction |
                             shs_instruction |
                             slo_instruction

private sCC_tail ::= data_size_byte? adm_group_all_except_ard_pc_imm

seq_instruction ::= SEQ sCC_tail
sne_instruction ::= SNE sCC_tail
spl_instruction ::= SPL sCC_tail
smi_instruction ::= SMI sCC_tail
svc_instruction ::= SVC sCC_tail
svs_instruction ::= SVS sCC_tail
st_instruction  ::= ST  sCC_tail
sf_instruction  ::= SF  sCC_tail
sge_instruction ::= SGE sCC_tail
sgt_instruction ::= SGT sCC_tail
sle_instruction ::= SLE sCC_tail
slt_instruction ::= SLT sCC_tail
scc_instruction ::= SCC sCC_tail
shi_instruction ::= SHI sCC_tail
sls_instruction ::= SLS sCC_tail
scs_instruction ::= SCS sCC_tail
shs_instruction ::= SHS sCC_tail
slo_instruction ::= SLO sCC_tail

// Bit =====================================================================
;
{
  extends("(bchg|bclr|bset|btst)_instruction") = bit_manipulation_instruction_base
}
private bit_manipulation_instructions ::= bchg_instruction |
                                          bclr_instruction |
                                          bset_instruction |
                                          btst_instruction

fake bit_manipulation_instruction_base ::=
{
  extends = data_sized
}

private bit_data_size ::= data_size_byte | data_size_long
{
  name = ".b|l"
}
private bit_tail ::= bit_data_size?
                     (adm_drd | adm_imm) COMMA adm_group_all_except_ard_pc_imm

bchg_instruction ::= BCHG bit_tail

bclr_instruction ::= BCLR bit_tail

bset_instruction ::= BSET bit_tail

btst_instruction ::= BTST bit_data_size?
                     (adm_drd | adm_imm) COMMA adm_group_all_except_ard


// Shift/Rotate ============================================================
;
{
  extends("(as.*|ls.*|ro.*)_instruction") = shift_rotate_instruction_base
}
private shift_rotate_instructions ::= asl_instruction |
                                      asr_instruction |
                                      lsl_instruction |
                                      lsr_instruction |
                                      rol_instruction |
                                      ror_instruction |
                                      roxl_instruction |
                                      roxr_instruction

fake shift_rotate_instruction_base ::=
{
  extends = data_sized
}

private shift_tail_drd ::= data_size_all? (adm_drd | adm_imm) COMMA adm_drd
{
  pin = 2
}
private shift_tail_other ::= data_size_word? (adm_api | adm_ari | adm_apd | adm_adi | adm_aix | adm_abs)
private shift_tail ::=
  (
     shift_tail_drd |
     shift_tail_other
  )

asl_instruction ::= ASL shift_tail
asr_instruction ::= ASR shift_tail

lsl_instruction ::= LSL shift_tail
lsr_instruction ::= LSR shift_tail

rol_instruction ::= ROL shift_tail
ror_instruction ::= ROR shift_tail

roxl_instruction ::= ROXL shift_tail
roxr_instruction ::= ROXR shift_tail


// Directives  ===================================================================
;
{
  psiPackage = "com.yanncebron.m68kplugin.lang.psi.directive"
  psiImplPackage = "com.yanncebron.m68kplugin.lang.psi.directive.impl"
  parserClass = "com.yanncebron.m68kplugin.lang.M68kDirectivesParser"
  implements("(blk|set|equr|even|odd|dc|dcb|ds|align|cnop|incbin|incdir|include|rsset|rsreset|rs)_directive") = "com.yanncebron.m68kplugin.lang.psi.directive.M68kDirective"
  implements("(opt|org|macro|endm|mexit|macro_parameter|macro_call|end|section|addwatch|jumperr|jumpptr|list|nolist|page|nopage|plen|llen|spc|inline|einline|rem|erem)_directive") = "com.yanncebron.m68kplugin.lang.psi.directive.M68kDirective"
  implements("(text|cseg|code|code_c|code_f|data|dseg|data_c|data_f|bss|bss_c|bss_f)_directive") = "com.yanncebron.m68kplugin.lang.psi.directive.M68kDirective"
  implements("equ_directive_base") = "com.yanncebron.m68kplugin.lang.psi.directive.M68kDirective"
  name(".*_directive") = "directive"
}

private directives ::= equ_directive |
                       blk_directive |
                       equals_directive |
                       set_directive |
                       equr_directive |
                       even_directive |
                       odd_directive |
                       dc_directive |
                       dcb_directive |
                       ds_directive |
                       align_directive |
                       cnop_directive |
                       incbin_directive |
                       incdir_directive |
                       include_directive |
                       rsset_directive |
                       rsreset_directive |
                       rs_directive |
                       opt_directive |
                       org_directive |
                       macro_directive |
                       endm_directive |
                       mexit_directive |
                       macro_parameter_directive |
                       macro_call_directive |
                       end_directive |
                       section_directive |
                       text_directive |
                       cseg_directive |
                       code_directive |
                       code_c_directive |
                       code_f_directive |
                       dseg_directive |
                       data_directive |
                       data_c_directive |
                       data_f_directive |
                       bss_directive |
                       bss_c_directive |
                       bss_f_directive |
                       addwatch_directive |
                       jumperr_directive |
                       jumpptr_directive |
                       list_directive |
                       nolist_directive |
                       page_directive |
                       nopage_directive |
                       plen_directive |
                       llen_directive |
                       spc_directive |
                       inline_directive |
                       einline_directive |
                       rem_directive |
                       erem_directive

fake equ_directive_base ::= label expression?
{
//  implements = "com.intellij.psi.PsiNameIdentifierOwner"
//  methods = [  getNameIdentifier]
}
equ_directive ::= label EQU expression
{
  pin = 2
  extends = equ_directive_base
}

equals_directive ::= label EQ expression
{
  pin = 2
  extends = equ_directive_base
}

set_directive ::= label SET expression
{
  pin = 2
  extends = equ_directive_base
}

equr_directive ::= label EQUR adm_rrd
{
  pin = 2
}

even_directive ::= EVEN
odd_directive ::= ODD

align_directive ::= ALIGN expression COMMA expression
{
  pin = 1
  methods = [
    expression = ""
    divisor = "expression[1]"
    offset = "expression[0]"
  ]
}
cnop_directive ::= CNOP expression COMMA expression
{
  pin = 1
  methods = [
    expression = ""
    divisor = "expression[1]"
    offset = "expression[0]"
  ]
}

end_directive ::= END

private section_type ::= CODE | CODE_C | CODE_F | TEXT | DATA | DATA_C | DATA_F | BSS | BSS_C | BSS_F
section_directive ::= SECTION ID (COMMA section_type)? (COMMA ID)?
{
  pin = 1
}
text_directive ::= TEXT
cseg_directive ::= CSEG
code_directive ::= CODE
code_c_directive ::= CODE_C
code_f_directive ::= CODE_F
dseg_directive ::= DSEG
data_directive ::= DATA
data_c_directive ::= DATA_C
data_f_directive ::= DATA_F
bss_directive ::= BSS
bss_c_directive ::= BSS_C
bss_f_directive ::= BSS_F

private include_path ::= STRING
{
  name = "include path"
}
incbin_directive ::= INCBIN include_path (COMMA expression)? (COMMA expression)?
{
  pin = 1
  methods = [
    getIncludePath
    expression = ""
    offset = "expression[0]"
    length = "expression[1]"
  ]
}
incdir_directive ::= INCDIR include_path
{
  pin = 1
  methods = [
    getIncludePath
  ]
}
include_directive ::= INCLUDE include_path
{
  pin = 1
  methods = [
    getIncludePath
  ]
}

dc_directive ::= DC data_size_all? expression (COMMA expression)*
{
  pin = 1
  extends = data_sized
}

dcb_directive ::= DCB data_size_all? expression (COMMA expression)?
{
  pin = 1
  extends = data_sized
  methods = [
    expression = ""
    number = "expression[0]"
    value = "expression[1]"
  ]
}

ds_directive ::= DS data_size_all? expression
{
  pin = 1
  extends = data_sized
}

rsset_directive ::= RSSET expression
{
  pin = 1
}
rsreset_directive ::= RSRESET
{
  pin = 1
}

rs_directive ::= RS data_size_all? expression?
{
  pin = 1
  extends = data_sized
}

blk_directive ::= BLK data_size_all? expression (COMMA expression)?
{
  pin = 1
  extends = data_sized
  methods = [
    expression = ""
    number = "expression[0]"
    value = "expression[1]"
  ]
}

private opt_element ::= ID (PLUS | MINUS)
{
  pin = 1
  name = "option(+|-)"
}
opt_directive ::= OPT opt_element (COMMA opt_element)*
{
  pin = 1
}

org_directive ::= ORG expression
{
  pin = 1
}

macro_directive ::= label MACRO
endm_directive ::= ENDM
mexit_directive ::= MEXIT

private macro_parameter_index_parameter ::= DEC_NUMBER
{
  name = "index"
}
macro_parameter_directive ::= BACKSLASH macro_parameter_index_parameter
{
  pin = 1
  methods = [
    indexElement = "macro_parameter_index_parameter"
  ]
}

macro_call_parameter ::= adm_group_all | adm_sr | adm_ccr | adm_usp
{
  name = "macro parameter"
}
macro_call_directive ::= <<afterWhitespace>> ID macro_call_parameter? (COMMA macro_call_parameter)*
{
  mixin = "com.yanncebron.m68kplugin.lang.psi.directive.impl.M68kMacrocallDirectiveMixIn"
}

addwatch_directive ::= ADDWATCH expression
{
  pin = 1
}

jumperr_directive ::= JUMPERR expression
{
  pin = 1
}

jumpptr_directive ::= JUMPPTR expression
{
  pin = 1
}

list_directive ::= LIST
nolist_directive ::= NOLIST

page_directive ::= PAGE
nopage_directive ::= NOPAGE
plen_directive ::= PLEN expression
{
  pin = 1
}
llen_directive ::= LLEN expression
{
  pin = 1
}
spc_directive ::= SPC expression
{
  pin = 1
}

inline_directive ::= INLINE
einline_directive ::= EINLINE

rem_directive ::= REM
erem_directive ::= EREM

// Expressions  ============================================================
;{
  parserClass = "com.yanncebron.m68kplugin.lang.M68kExpressionParser"
  psiPackage = "com.yanncebron.m68kplugin.lang.psi.expression"
  psiImplPackage="com.yanncebron.m68kplugin.lang.psi.expression.impl"
  extends("(plus|minus|mul|div|mod|exp|shift.*|or|and)_expression") = binary_expression
  extends(".*expression") = expression
  consumeTokenMethod(".*expression")="consumeTokenFast"
}

expression ::= add_group |
               mul_group |
               unary_group |
               exp_expression |
               shift_group |
               bool_group |
               primary_group

fake binary_expression ::= expression+
{
  methods = [
    expression = ""
    left = "expression[0]"
    right = "expression[1]"
  ]
  pin = 2
}

private add_group ::= plus_expression | minus_expression
plus_expression ::= expression PLUS expression
minus_expression ::= expression MINUS expression

private mul_group ::= mul_expression | div_expression | mod_expression
mul_expression ::= expression MUL expression
div_expression ::= expression DIV expression
mod_expression ::= expression PERCENT expression

private unary_group ::= unary_plus_expression | unary_minus_expression | unary_complement_expression
unary_plus_expression ::= PLUS expression
unary_minus_expression ::= MINUS expression
unary_complement_expression ::= TILDE expression

exp_expression ::= expression POW expression  // todo is this XOR?

private shift_group ::= shift_left_expression | shift_right_expression
shift_left_expression ::= expression SHIFT_L expression
shift_right_expression ::= expression SHIFT_R expression

private bool_group ::= or_expression | and_expression
or_expression ::= expression PIPE expression
and_expression ::= expression AMPERSAND expression

private primary_group ::= number_expression | string_expression | paren_expression | label_ref_expression
number_expression ::= DEC_NUMBER | HEX_NUMBER | OCT_NUMBER | BIN_NUMBER
string_expression ::= STRING

private plain_paren_expression ::= L_PAREN expression R_PAREN
private bracket_paren_expression ::= L_BRACKET expression R_BRACKET
paren_expression ::= plain_paren_expression | bracket_paren_expression

label_ref_expression ::= ID
{
  mixin = "com.yanncebron.m68kplugin.lang.psi.expression.impl.M68kLabelRefExpressionMixIn"
  name = "label"
}


;
{
  parserClass = "com.yanncebron.m68kplugin.lang.M68kConditionalAssemblyParser"
  psiPackage = "com.yanncebron.m68kplugin.lang.psi.conditional"
  psiImplPackage = "com.yanncebron.m68kplugin.lang.psi.conditional.impl"
  implements(".*_conditional_assembly_directive") = "com.yanncebron.m68kplugin.lang.psi.conditional.M68kConditionalAssemblyDirective"
  pin(".*_conditional_assembly_directive") = 1
}
private conditional_assembly_directives ::= if_conditional_assembly_directive |
                                            ifd_conditional_assembly_directive |
                                            ifeq_conditional_assembly_directive |
                                            ifge_conditional_assembly_directive |
                                            ifgt_conditional_assembly_directive |
                                            ifnd_conditional_assembly_directive |
                                            ifle_conditional_assembly_directive |
                                            iflt_conditional_assembly_directive |
                                            ifne_conditional_assembly_directive |
                                            ifb_conditional_assembly_directive |
                                            ifnb_conditional_assembly_directive |
                                            ifc_conditional_assembly_directive |
                                            ifnc_conditional_assembly_directive |
                                            else_conditional_assembly_directive |
                                            elseif_conditional_assembly_directive |
                                            endc_conditional_assembly_directive |
                                            endif_conditional_assembly_directive |
                                            ifmacrod_conditional_assembly_directive |
                                            ifmacrond_conditional_assembly_directive


if_conditional_assembly_directive ::= IF expression
ifd_conditional_assembly_directive ::= IFD expression
ifnd_conditional_assembly_directive ::= IFND expression

ifeq_conditional_assembly_directive ::= IFEQ expression
ifge_conditional_assembly_directive ::= IFGE expression
ifgt_conditional_assembly_directive ::= IFGT expression
ifle_conditional_assembly_directive ::= IFLE expression
iflt_conditional_assembly_directive ::= IFLT expression
ifne_conditional_assembly_directive ::= IFNE expression

ifb_conditional_assembly_directive ::= IFB expression
ifnb_conditional_assembly_directive ::= IFNB expression
ifc_conditional_assembly_directive ::= IFC expression COMMA expression {
  methods = [
    expression = ""
    arg1 = "expression[0]"
    arg2 = "expression[1]"
  ]
}
ifnc_conditional_assembly_directive ::= IFNC expression COMMA expression {
  methods = [
    expression = ""
    arg1 = "expression[0]"
    arg2 = "expression[1]"
  ]
}

ifmacrod_conditional_assembly_directive ::= IFMACROD expression
ifmacrond_conditional_assembly_directive ::= IFMACROND expression

elseif_conditional_assembly_directive ::= ELSEIF
else_conditional_assembly_directive ::= ELSE
endc_conditional_assembly_directive ::= ENDC
endif_conditional_assembly_directive ::= ENDIF
